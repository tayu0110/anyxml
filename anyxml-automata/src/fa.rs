use std::{
    collections::{HashMap, HashSet},
    hash::{BuildHasher, Hash, RandomState},
    ops::RangeInclusive,
    sync::atomic::AtomicUsize,
};

use crate::ast::ASTNode;

// Since NULL characters are not used in XML, it should be fine for internal use...
const EPSILON: char = char::MIN;
const EPSILON_RANGE: RangeInclusive<char> = EPSILON..=EPSILON;

#[derive(Debug, PartialEq, Eq, Default)]
struct FAFragment {
    is_accepted: bool,
    rule_map: Vec<(RangeInclusive<char>, usize)>,
}

impl PartialOrd for FAFragment {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for FAFragment {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        if self.is_accepted != other.is_accepted {
            self.is_accepted.cmp(&other.is_accepted)
        } else {
            self.rule_map
                .iter()
                .map(|(key, to)| (key.start(), key.end(), to))
                .cmp(
                    other
                        .rule_map
                        .iter()
                        .map(|(key, to)| (key.start(), key.end(), to)),
                )
        }
    }
}

static AUTOMATON_ID: AtomicUsize = AtomicUsize::new(0);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct State {
    index: usize,
    // Identify which automaton generated this state.
    fa_id: usize,
}

impl State {
    /// Check whether this state is generated from the given DFA.
    pub fn generated_by(&self, dfa: &DFA) -> bool {
        self.fa_id == dfa.id
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum TransitionError {
    /// A state generated from a different FA or an invalid state generated by an internal error.
    InvalidState,
    /// Reached a reject state and there is no state that can be returned.
    InputIsRejected,
}

impl std::fmt::Display for TransitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self:?}")
    }
}

impl std::error::Error for TransitionError {}

#[allow(clippy::upper_case_acronyms)]
struct NFA {
    id: usize,
    initial_state: usize,
    states: Vec<FAFragment>,
}

impl NFA {
    fn convert_to_dfa(mut self) -> DFA {
        self.states.iter_mut().for_each(|frag| {
            frag.rule_map
                .sort_unstable_by_key(|(k, v)| (*k.start(), *v));
            frag.rule_map.dedup();
        });

        let mut states = vec![];
        let mut cur = HashSet::from([self.initial_state]);
        let mut stack = vec![self.initial_state];
        while let Some(now) = stack.pop() {
            for &(_, to) in self.states[now]
                .rule_map
                .iter()
                .take_while(|v| v.0.start() == &EPSILON)
            {
                if cur.insert(to) {
                    stack.push(to);
                }
            }
        }
        let hash_state = RandomState::new();

        // I use Zobrist Hashing to improve the efficiency of set matching and memory efficiency.
        fn generate_hash(set: &HashSet<usize>, state: &RandomState) -> u64 {
            set.iter()
                .copied()
                .map(|id| state.hash_one(id))
                .fold(0, |s, v| s ^ v)
        }

        fn build_states(
            hash: u64,
            cur: &HashSet<usize>,
            hash_state: &RandomState,
            old_states: &[FAFragment],
            states: &mut Vec<FAFragment>,
            memo: &mut HashMap<u64, usize>,
        ) -> usize {
            let state_index = states.len();
            memo.insert(hash, state_index);
            states.push(FAFragment::default());
            if cur.iter().any(|index| old_states[*index].is_accepted) {
                states[state_index].is_accepted = true;
            }

            // List transitions other than ε.
            let mut rules = vec![];
            for &c in cur.iter() {
                rules.extend(
                    old_states[c]
                        .rule_map
                        .iter()
                        .filter(|&v| v.0 != EPSILON_RANGE)
                        .cloned(),
                );
            }
            rules.sort_unstable_by_key(|v| (*v.0.start(), v.1));
            rules.dedup();

            if rules.is_empty() {
                return state_index;
            }
            let mut rule = rules[0].0.clone();
            let mut buf = vec![];
            let mut set = HashSet::new();
            let mut push_state = |rule: RangeInclusive<char>, buf: &mut Vec<usize>| {
                set.clear();
                set.extend(buf.iter().copied());
                // `buf` contains a set of states that can be reached from the current state with a single transition based on a given rule.
                // Furthermore, we list the sets that can be reached using only ε from these states.
                while let Some(now) = buf.pop() {
                    for to in old_states[now]
                        .rule_map
                        .iter()
                        .take_while(|v| v.0 == EPSILON_RANGE)
                    {
                        if set.insert(to.1) {
                            buf.push(to.1);
                        }
                    }
                }
                let hash = generate_hash(&set, hash_state);
                if let Some(to) = memo.get(&hash) {
                    // If the listed set has already been created, add the rule to the existing set.
                    states[state_index].rule_map.push((rule, *to));
                } else {
                    // Otherwise, continue searching as it is a newly discovered set.
                    let index = build_states(hash, &set, hash_state, old_states, states, memo);
                    states[state_index].rule_map.push((rule, index));
                }
            };
            for (r, to) in rules {
                if rule == r {
                    buf.push(to);
                    continue;
                }

                if !buf.is_empty() {
                    push_state(rule, &mut buf);
                    // Here, the buffer must be emptied, but since it is emptied in `push_state`,
                    // no additional operations are necessary.
                    debug_assert!(buf.is_empty());
                }

                rule = r;
                buf.push(to);
            }

            if !buf.is_empty() {
                push_state(rule, &mut buf);
            }
            state_index
        }

        build_states(
            generate_hash(&cur, &hash_state),
            &cur,
            &hash_state,
            &self.states,
            &mut states,
            &mut HashMap::new(),
        );

        DFA {
            id: self.id,
            states,
        }
    }
}

pub struct DFA {
    id: usize,
    // The rule_map for each fragment must be sorted.
    // This constraint allows us to search for the transition destination using binary search.
    states: Vec<FAFragment>,
}

impl DFA {
    fn empty() -> Self {
        let id = AUTOMATON_ID.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        Self {
            id,
            states: vec![FAFragment {
                is_accepted: true,
                rule_map: vec![],
            }],
        }
    }

    /// Returns the initial state.
    pub fn initial_state(&self) -> State {
        State {
            index: 0,
            fa_id: self.id,
        }
    }

    /// Returns the destination state when `input` is entered, using `initial_state` as the initial state.
    ///
    /// `initial_state` does not need to be a state generated by [`DFA::initial_state`]; it can also be a state generated by [`DFA::transition`], etc.  
    /// For example, you can use this when you want to enter a chunked string little by little.
    pub fn transition(
        &self,
        initial_state: State,
        input: impl Iterator<Item = char>,
    ) -> Result<State, TransitionError> {
        if initial_state.fa_id != self.id {
            return Err(TransitionError::InvalidState);
        }

        let mut state = initial_state.index;
        if self.states.len() <= state {
            return Err(TransitionError::InvalidState);
        }

        for c in input {
            debug_assert!(
                self.states[state]
                    .rule_map
                    .windows(2)
                    .all(|v| v[0].0.end() < v[1].0.start())
            );
            state = self.states[state]
                .rule_map
                .binary_search_by(|(rule, _)| {
                    if &c < rule.start() {
                        std::cmp::Ordering::Greater
                    } else if rule.end() < &c {
                        std::cmp::Ordering::Less
                    } else {
                        std::cmp::Ordering::Equal
                    }
                })
                .map_err(|_| TransitionError::InputIsRejected)?;
        }

        Ok(State {
            index: state,
            fa_id: self.id,
        })
    }

    /// Check whether the entered string is accepted.
    pub fn is_match(&self, input: impl Iterator<Item = char>) -> bool {
        self.is_accepted(self.transition(self.initial_state(), input).unwrap())
    }

    /// Check if the given state is an accepted state.
    ///
    /// If the given state is not generated from this DFA, always return false.
    pub fn is_accepted(&self, state: State) -> bool {
        state.fa_id == self.id && self.states[state.index].is_accepted
    }

    fn minimize(&mut self) {
        let mut replace_to = (0..self.states.len()).collect::<Vec<_>>();
        let mut index = (0..self.states.len()).collect::<Vec<_>>();
        loop {
            index.sort_unstable_by_key(|&index| (&self.states[index], index));
            let mut update = false;
            for v in index.windows(2) {
                let l = v[0];
                let r = v[1];

                if self.states[l] == self.states[r] {
                    // Always merge to the smaller index.
                    // As a result, the index of the initial state is kept at 0.
                    replace_to[r] = replace_to[l];
                    update = true;
                }
            }

            if !update {
                break;
            }

            for &index in &index {
                if index == replace_to[index] {
                    for (_, to) in self.states[index].rule_map.iter_mut() {
                        *to = replace_to[*to];
                    }
                }
            }
            index.retain(|&index| index == replace_to[index]);
        }

        index.sort_unstable();
        for (to, &from) in index.iter().enumerate() {
            self.states.swap(to, from);
            replace_to[from] = to;
        }
        self.states.truncate(index.len());
        for state in self.states.iter_mut() {
            for (_, to) in state.rule_map.iter_mut() {
                *to = replace_to[*to];
            }
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FAAssembleError {
    InvalidQuantifier,
}

impl std::fmt::Display for FAAssembleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self:?}")
    }
}

impl std::error::Error for FAAssembleError {}

/// Build a DFA from the AST. If the build fails, return `Err`.
///
/// If `None` is entered, this function always returns `Ok`.  
/// In this case, the DFA has only one state that is both the input state and the accepting state.  
/// For example, it is likely that the regular expression converted to AST would be an empty string.
pub fn assemble(ast: Option<&ASTNode>) -> Result<DFA, FAAssembleError> {
    let Some(ast) = ast else {
        return Ok(DFA::empty());
    };

    let nfa = build_nfa(ast)?;
    let mut dfa = nfa.convert_to_dfa();
    dfa.minimize();
    Ok(dfa)
}

fn build_nfa(ast: &ASTNode) -> Result<NFA, FAAssembleError> {
    // ranges: (point, is_end)
    fn collect_character_ranges(ast: &ASTNode, ranges: &mut Vec<(char, bool)>) {
        match ast {
            ASTNode::Charcters { range, negation: _ } => {
                ranges.push((*range.start(), false));
                ranges.push((*range.end(), true));
            }
            ASTNode::Catenation(front, back) => {
                collect_character_ranges(front, ranges);
                collect_character_ranges(back, ranges);
            }
            ASTNode::Alternation(left, right) => {
                collect_character_ranges(left, ranges);
                collect_character_ranges(right, ranges);
            }
            ASTNode::ZeroOrOne(node) => {
                collect_character_ranges(node, ranges);
            }
            ASTNode::ZeroOrMore(node) => {
                collect_character_ranges(node, ranges);
            }
            ASTNode::OneOrMore(node) => {
                collect_character_ranges(node, ranges);
            }
            ASTNode::Repeat {
                node,
                at_least: _,
                at_most: _,
            } => {
                collect_character_ranges(node, ranges);
            }
            ASTNode::RepeatExact(node, _) => {
                collect_character_ranges(node, ranges);
            }
        }
    }

    let mut ranges = vec![(char::MIN, false), (char::MAX, true)];
    collect_character_ranges(ast, &mut ranges);
    ranges.sort_unstable();
    ranges.dedup();
    let ranges = ranges
        .windows(2)
        .filter_map(|v| {
            let (mut start, f) = v[0];
            let (mut end, g) = v[1];
            if start == end {
                Some((start, end))
            } else {
                if f {
                    start = (start..).next()?;
                }
                if !g {
                    end = ('\0'..end).next_back()?;
                }
                (start <= end).then_some((start, end))
            }
        })
        .collect::<Vec<_>>();

    fn build_states(
        ast: &ASTNode,
        ranges: &[(char, char)],
        states: &mut Vec<FAFragment>,
    ) -> Result<(usize, usize), FAAssembleError> {
        match ast {
            ASTNode::Charcters { range, negation } => {
                let &start = range.start();
                let &end = range.end();
                let mut pos = ranges.partition_point(|p| p.0 < start);
                let mut from = FAFragment::default();
                let to = FAFragment {
                    is_accepted: true,
                    ..Default::default()
                };
                if *negation {
                    for &(f, t) in ranges.iter().take(pos) {
                        from.rule_map.push((f..=t, states.len()));
                    }
                    while pos < ranges.len() && ranges[pos].1 <= end {
                        pos += 1;
                    }
                    for &(f, t) in ranges.iter().skip(pos) {
                        from.rule_map.push((f..=t, states.len()));
                    }
                } else {
                    while pos < ranges.len() && ranges[pos].1 <= end {
                        let (s, e) = ranges[pos];
                        from.rule_map.push((s..=e, states.len()));
                        pos += 1;
                    }
                }
                states.push(from);
                states.push(to);
                Ok((states.len() - 2, states.len() - 1))
            }
            ASTNode::Catenation(front, back) => {
                // [sf -> ... -> ef] -> [sb -> ... -> eb]
                let (sf, ef) = build_states(front, ranges, states)?;
                let (sb, eb) = build_states(back, ranges, states)?;
                states[ef].rule_map.push((EPSILON_RANGE, sb));
                Ok((sf, eb))
            }
            ASTNode::Alternation(left, right) => {
                //       ┌─> [sl -> ... -> el] ─┐
                // start ┤                      ├─> end
                //       └─> [sr -> ... -> er] ─┘
                let (sl, el) = build_states(left, ranges, states)?;
                let (sr, er) = build_states(right, ranges, states)?;
                let mut start = FAFragment::default();
                start.rule_map.push((EPSILON_RANGE, sl));
                start.rule_map.push((EPSILON_RANGE, sr));
                states.push(start);
                let mut end = FAFragment::default();
                let len = states.len();
                states[el].rule_map.push((EPSILON_RANGE, len));
                states[el].is_accepted = false;
                states[er].rule_map.push((EPSILON_RANGE, len));
                states[er].is_accepted = false;
                end.is_accepted = true;
                states.push(end);
                Ok((states.len() - 2, states.len() - 1))
            }
            ASTNode::ZeroOrOne(node) => {
                // [start -> ... -> end]
                //   │               ^
                //   └───────────────┘
                let (start, end) = build_states(node, ranges, states)?;
                states[start].rule_map.push((EPSILON_RANGE, end));
                Ok((start, end))
            }
            ASTNode::ZeroOrMore(node) => {
                // [start -> ... -> end] -> new_end
                //   │ ^             │         ^
                //   │ └─────────────┘         │
                //   └─────────────────────────┘
                let (start, end) = build_states(node, ranges, states)?;
                let mut new_end = FAFragment::default();
                states[end].is_accepted = false;
                new_end.is_accepted = true;
                let len = states.len();
                states[start].rule_map.push((EPSILON_RANGE, len));
                states[end].rule_map.push((EPSILON_RANGE, len));
                states[end].rule_map.push((EPSILON_RANGE, start));
                states.push(new_end);
                Ok((start, states.len() - 1))
            }
            ASTNode::OneOrMore(node) => {
                // [start -> ... -> end] -> [start2 -> ... -> end2] -> new_end
                //                            │ ^               │         ^
                //                            │ └───────────────┘         │
                //                            └───────────────────────────┘
                let (start, end) = build_states(node, ranges, states)?;
                let (start2, end2) = build_states(node, ranges, states)?;
                states[end].is_accepted = false;
                states[end2].is_accepted = false;
                states[end].rule_map.push((EPSILON_RANGE, start2));
                let new_end = FAFragment {
                    is_accepted: true,
                    ..Default::default()
                };
                let len = states.len();
                states[start2].rule_map.push((EPSILON_RANGE, len));
                states[end2].rule_map.push((EPSILON_RANGE, len));
                states[end2].rule_map.push((EPSILON_RANGE, start2));
                states.push(new_end);
                Ok((start, states.len() - 1))
            }
            ASTNode::Repeat {
                node,
                at_least,
                at_most,
            } => {
                let new_start = FAFragment::default();
                states.push(new_start);
                let new_start = states.len() - 1;
                let new_end = FAFragment {
                    is_accepted: true,
                    ..Default::default()
                };
                states.push(new_end);
                let new_end = states.len() - 1;

                let mut start = new_start;
                for _ in 0..*at_least {
                    let (new_start, new_end) = build_states(node, ranges, states)?;
                    states[start].rule_map.push((EPSILON_RANGE, new_start));
                    states[new_end].is_accepted = false;
                    start = new_end;
                }
                if let &Some(at_most) = at_most {
                    if *at_least > at_most {
                        return Err(FAAssembleError::InvalidQuantifier);
                    }
                    for _ in *at_least..at_most {
                        let (new_start, end) = build_states(node, ranges, states)?;
                        states[start].rule_map.push((EPSILON_RANGE, new_start));
                        states[start].rule_map.push((EPSILON_RANGE, new_end));
                        states[end].is_accepted = false;
                        start = end;
                    }
                    states[start].rule_map.push((EPSILON_RANGE, new_end));
                } else {
                    let (new_start, end) = build_states(node, ranges, states)?;
                    states[start].rule_map.push((EPSILON_RANGE, new_start));
                    states[start].rule_map.push((EPSILON_RANGE, new_end));
                    states[end].rule_map.push((EPSILON_RANGE, new_end));
                    states[end].rule_map.push((EPSILON_RANGE, new_start));
                    states[end].is_accepted = false;
                }

                Ok((new_start, new_end))
            }
            ASTNode::RepeatExact(node, n) => {
                let new_start = FAFragment::default();
                states.push(new_start);
                let new_start = states.len() - 1;
                let new_end = FAFragment {
                    is_accepted: true,
                    ..Default::default()
                };
                states.push(new_end);
                let new_end = states.len() - 1;

                let mut start = new_start;
                for _ in 0..*n {
                    let (new_start, end) = build_states(node, ranges, states)?;
                    states[start].rule_map.push((EPSILON_RANGE, new_start));
                    states[end].is_accepted = false;
                    start = end;
                }

                states[start].rule_map.push((EPSILON_RANGE, new_end));

                Ok((new_start, new_end))
            }
        }
    }

    let mut states = vec![];
    let (initial_state, _) = build_states(ast, &ranges, &mut states)?;

    Ok(NFA {
        id: AUTOMATON_ID.fetch_add(1, std::sync::atomic::Ordering::Relaxed),
        initial_state,
        states,
    })
}
