use std::{
    collections::{HashMap, HashSet},
    hash::{BuildHasher, Hash, RandomState},
    marker::PhantomData,
    sync::atomic::AtomicUsize,
};

use crate::{Atom, ast::ASTNode};

#[derive(Debug, PartialEq, Eq, Default)]
struct FAFragment<A: Atom> {
    is_accepted: bool,
    // (start, end, to)
    rule_map: Vec<(A, A, usize)>,
}

impl<A: Atom> PartialOrd for FAFragment<A> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl<A: Atom> Ord for FAFragment<A> {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        if self.is_accepted != other.is_accepted {
            self.is_accepted.cmp(&other.is_accepted)
        } else {
            self.rule_map
                .iter()
                .map(|(start, end, to)| (start, end, to))
                .cmp(
                    other
                        .rule_map
                        .iter()
                        .map(|(start, end, to)| (start, end, to)),
                )
        }
    }
}

static AUTOMATON_ID: AtomicUsize = AtomicUsize::new(0);

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct State<A: Atom> {
    index: usize,
    // Identify which automaton generated this state.
    fa_id: usize,
    _phantom: PhantomData<fn() -> A>,
}

impl<A: Atom> State<A> {
    /// Check whether this state is generated from the given DFA.
    pub fn generated_by(&self, dfa: &DFA<A>) -> bool {
        self.fa_id == dfa.id
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum TransitionError {
    /// A state generated from a different FA or an invalid state generated by an internal error.
    InvalidState,
    /// Reached a reject state and there is no state that can be returned.
    InputIsRejected,
}

impl std::fmt::Display for TransitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self:?}")
    }
}

impl std::error::Error for TransitionError {}

#[allow(clippy::upper_case_acronyms)]
struct NFA<A: Atom> {
    id: usize,
    initial_state: usize,
    states: Vec<FAFragment<A>>,
}

impl<A: Atom> NFA<A> {
    fn convert_to_dfa(mut self) -> DFA<A> {
        self.states.iter_mut().for_each(|frag| {
            frag.rule_map
                .sort_unstable_by_key(|(start, _, v)| (*start, *v));
            frag.rule_map.dedup();
        });

        let mut states = vec![];
        let mut cur = HashSet::from([self.initial_state]);
        let mut stack = vec![self.initial_state];
        while let Some(now) = stack.pop() {
            for &(_, _, to) in self.states[now]
                .rule_map
                .iter()
                .take_while(|v| v.0 == A::EPSILON)
            {
                if cur.insert(to) {
                    stack.push(to);
                }
            }
        }
        let hash_state = RandomState::new();

        // I use Zobrist Hashing to improve the efficiency of set matching and memory efficiency.
        fn generate_hash(set: &HashSet<usize>, state: &RandomState) -> u64 {
            set.iter()
                .copied()
                .map(|id| state.hash_one(id))
                .fold(0, |s, v| s ^ v)
        }

        fn build_states<A: Atom>(
            hash: u64,
            cur: &HashSet<usize>,
            hash_state: &RandomState,
            old_states: &[FAFragment<A>],
            states: &mut Vec<FAFragment<A>>,
            memo: &mut HashMap<u64, usize>,
        ) -> usize {
            let state_index = states.len();
            memo.insert(hash, state_index);
            states.push(FAFragment::default());
            if cur.iter().any(|index| old_states[*index].is_accepted) {
                states[state_index].is_accepted = true;
            }

            // List transitions other than ε.
            let mut rules = vec![];
            for &c in cur.iter() {
                rules.extend(
                    old_states[c]
                        .rule_map
                        .iter()
                        .filter(|&v| v.0 != A::EPSILON)
                        .cloned(),
                );
            }
            rules.sort_unstable_by_key(|v| (v.0, v.2));
            rules.dedup();

            if rules.is_empty() {
                return state_index;
            }
            let mut rule = (rules[0].0, rules[0].1);
            let mut buf = vec![];
            let mut set = HashSet::new();
            let mut push_state = |rule: (A, A), buf: &mut Vec<usize>| {
                set.clear();
                set.extend(buf.iter().copied());
                // `buf` contains a set of states that can be reached from the current state with a single transition based on a given rule.
                // Furthermore, we list the sets that can be reached using only ε from these states.
                while let Some(now) = buf.pop() {
                    for to in old_states[now]
                        .rule_map
                        .iter()
                        .take_while(|v| v.0 == A::EPSILON)
                    {
                        if set.insert(to.2) {
                            buf.push(to.2);
                        }
                    }
                }
                let hash = generate_hash(&set, hash_state);
                if let Some(to) = memo.get(&hash) {
                    // If the listed set has already been created, add the rule to the existing set.
                    states[state_index].rule_map.push((rule.0, rule.1, *to));
                } else {
                    // Otherwise, continue searching as it is a newly discovered set.
                    let index = build_states(hash, &set, hash_state, old_states, states, memo);
                    states[state_index].rule_map.push((rule.0, rule.1, index));
                }
            };
            for (start, end, to) in rules {
                if rule == (start, end) {
                    buf.push(to);
                    continue;
                }

                if !buf.is_empty() {
                    push_state(rule, &mut buf);
                    // Here, the buffer must be emptied, but since it is emptied in `push_state`,
                    // no additional operations are necessary.
                    debug_assert!(buf.is_empty());
                }

                rule = (start, end);
                buf.push(to);
            }

            if !buf.is_empty() {
                push_state(rule, &mut buf);
            }
            state_index
        }

        build_states(
            generate_hash(&cur, &hash_state),
            &cur,
            &hash_state,
            &self.states,
            &mut states,
            &mut HashMap::new(),
        );

        DFA {
            id: self.id,
            states,
        }
    }
}

#[derive(Debug)]
pub struct DFA<A: Atom> {
    id: usize,
    // The rule_map for each fragment must be sorted.
    // This constraint allows us to search for the transition destination using binary search.
    states: Vec<FAFragment<A>>,
}

impl<A: Atom> DFA<A> {
    fn empty() -> Self {
        let id = AUTOMATON_ID.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        Self {
            id,
            states: vec![FAFragment {
                is_accepted: true,
                rule_map: vec![],
            }],
        }
    }

    /// Returns the initial state.
    pub fn initial_state(&self) -> State<A> {
        State {
            index: 0,
            fa_id: self.id,
            _phantom: PhantomData,
        }
    }

    /// Returns the destination state when `input` is entered, using `initial_state` as the initial state.
    ///
    /// `initial_state` does not need to be a state generated by [`DFA::initial_state`]; it can also be a state generated by [`DFA::transition`], etc.  
    /// For example, you can use this when you want to enter a chunked string little by little.
    pub fn transition(
        &self,
        initial_state: State<A>,
        input: impl Iterator<Item = A>,
    ) -> Result<State<A>, TransitionError> {
        if initial_state.fa_id != self.id {
            return Err(TransitionError::InvalidState);
        }

        let mut state = initial_state.index;
        if self.states.len() <= state {
            return Err(TransitionError::InvalidState);
        }

        for c in input {
            debug_assert!(
                self.states[state]
                    .rule_map
                    .windows(2)
                    .all(|v| v[0].1 < v[1].0)
            );
            state = self.states[state]
                .rule_map
                .binary_search_by(|(start, end, _)| {
                    if &c < start {
                        std::cmp::Ordering::Greater
                    } else if end < &c {
                        std::cmp::Ordering::Less
                    } else {
                        std::cmp::Ordering::Equal
                    }
                })
                .map(|index| self.states[state].rule_map[index].2)
                .map_err(|_| TransitionError::InputIsRejected)?;
        }

        Ok(State {
            index: state,
            fa_id: self.id,
            _phantom: PhantomData,
        })
    }

    /// Check whether the entered string is accepted.
    pub fn is_match(&self, input: impl Iterator<Item = A>) -> bool {
        self.transition(self.initial_state(), input)
            .is_ok_and(|state| self.is_accepted(state))
    }

    /// Check if the given state is an accepted state.
    ///
    /// If the given state is not generated from this DFA, always return false.
    pub fn is_accepted(&self, state: State<A>) -> bool {
        state.fa_id == self.id && self.states[state.index].is_accepted
    }

    fn minimize(&mut self) {
        let mut replace_to = (0..self.states.len()).collect::<Vec<_>>();
        let mut index = (0..self.states.len()).collect::<Vec<_>>();
        loop {
            index.sort_unstable_by_key(|&index| (&self.states[index], index));
            let mut update = false;
            for v in index.windows(2) {
                let l = v[0];
                let r = v[1];

                if self.states[l] == self.states[r] {
                    // Always merge to the smaller index.
                    // As a result, the index of the initial state is kept at 0.
                    replace_to[r] = replace_to[l];
                    update = true;
                }
            }

            if !update {
                break;
            }

            for &index in &index {
                if index == replace_to[index] {
                    for (_, _, to) in self.states[index].rule_map.iter_mut() {
                        *to = replace_to[*to];
                    }
                }
            }
            index.retain(|&index| index == replace_to[index]);
        }

        index.sort_unstable();
        for (to, &from) in index.iter().enumerate() {
            self.states.swap(to, from);
            replace_to[from] = to;
        }
        self.states.truncate(index.len());
        for state in self.states.iter_mut() {
            for (_, _, to) in state.rule_map.iter_mut() {
                *to = replace_to[*to];
            }
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum FAAssembleError {
    InvalidQuantifier,
}

impl std::fmt::Display for FAAssembleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self:?}")
    }
}

impl std::error::Error for FAAssembleError {}

/// Build a DFA from the AST. If the build fails, return `Err`.
///
/// If `None` is entered, this function always returns `Ok`.  
/// In this case, the DFA has only one state that is both the input state and the accepting state.  
/// For example, it is likely that the regular expression converted to AST would be an empty string.
pub fn assemble<A: Atom>(ast: Option<&ASTNode<A>>) -> Result<DFA<A>, FAAssembleError> {
    let Some(ast) = ast else {
        return Ok(DFA::empty());
    };

    let nfa = build_nfa(ast)?;
    let mut dfa = nfa.convert_to_dfa();
    dfa.minimize();
    Ok(dfa)
}

fn build_nfa<A: Atom>(ast: &ASTNode<A>) -> Result<NFA<A>, FAAssembleError> {
    // ranges: (point, is_end)
    fn collect_character_ranges<A: Atom>(ast: &ASTNode<A>, ranges: &mut Vec<(A, bool)>) {
        match ast {
            ASTNode::Charcters {
                start,
                end,
                negation: _,
            } => {
                ranges.push((*start, false));
                ranges.push((*end, true));
            }
            ASTNode::Catenation(front, back) => {
                collect_character_ranges(front, ranges);
                collect_character_ranges(back, ranges);
            }
            ASTNode::Alternation(left, right) => {
                collect_character_ranges(left, ranges);
                collect_character_ranges(right, ranges);
            }
            ASTNode::ZeroOrOne(node) => {
                collect_character_ranges(node, ranges);
            }
            ASTNode::ZeroOrMore(node) => {
                collect_character_ranges(node, ranges);
            }
            ASTNode::OneOrMore(node) => {
                collect_character_ranges(node, ranges);
            }
            ASTNode::Repeat {
                node,
                at_least: _,
                at_most: _,
            } => {
                collect_character_ranges(node, ranges);
            }
            ASTNode::RepeatExact(node, _) => {
                collect_character_ranges(node, ranges);
            }
        }
    }

    let mut ranges = vec![(A::MIN, false), (A::MAX, true)];
    collect_character_ranges(ast, &mut ranges);
    ranges.sort_unstable();
    ranges.dedup();
    let ranges = ranges
        .windows(2)
        .filter_map(|v| {
            let (mut start, f) = v[0];
            let (mut end, g) = v[1];
            if start == end {
                Some((start, end))
            } else {
                if f {
                    start = start.next()?;
                }
                if !g {
                    end = end.previous()?;
                }
                (start <= end).then_some((start, end))
            }
        })
        .collect::<Vec<_>>();

    fn build_states<A: Atom>(
        ast: &ASTNode<A>,
        ranges: &[(A, A)],
        states: &mut Vec<FAFragment<A>>,
    ) -> Result<(usize, usize), FAAssembleError> {
        match ast {
            &ASTNode::Charcters {
                start,
                end,
                negation,
            } => {
                let mut pos = ranges.partition_point(|p| p.0 < start);
                let mut from = FAFragment::default();
                let to = FAFragment {
                    is_accepted: true,
                    ..Default::default()
                };
                if negation {
                    for &(f, t) in ranges.iter().take(pos) {
                        from.rule_map.push((f, t, states.len() + 1));
                    }
                    while pos < ranges.len() && ranges[pos].1 <= end {
                        pos += 1;
                    }
                    for &(f, t) in ranges.iter().skip(pos) {
                        from.rule_map.push((f, t, states.len() + 1));
                    }
                } else {
                    while pos < ranges.len() && ranges[pos].1 <= end {
                        let (s, e) = ranges[pos];
                        from.rule_map.push((s, e, states.len() + 1));
                        pos += 1;
                    }
                }
                states.push(from);
                states.push(to);
                Ok((states.len() - 2, states.len() - 1))
            }
            ASTNode::Catenation(front, back) => {
                // [sf -> ... -> ef] -> [sb -> ... -> eb]
                let (sf, ef) = build_states(front, ranges, states)?;
                let (sb, eb) = build_states(back, ranges, states)?;
                states[ef].rule_map.push((A::EPSILON, A::EPSILON, sb));
                states[ef].is_accepted = false;
                Ok((sf, eb))
            }
            ASTNode::Alternation(left, right) => {
                //       ┌─> [sl -> ... -> el] ─┐
                // start ┤                      ├─> end
                //       └─> [sr -> ... -> er] ─┘
                let (sl, el) = build_states(left, ranges, states)?;
                let (sr, er) = build_states(right, ranges, states)?;
                let mut start = FAFragment::default();
                start.rule_map.push((A::EPSILON, A::EPSILON, sl));
                start.rule_map.push((A::EPSILON, A::EPSILON, sr));
                states.push(start);
                let mut end = FAFragment::default();
                let len = states.len();
                states[el].rule_map.push((A::EPSILON, A::EPSILON, len));
                states[el].is_accepted = false;
                states[er].rule_map.push((A::EPSILON, A::EPSILON, len));
                states[er].is_accepted = false;
                end.is_accepted = true;
                states.push(end);
                Ok((states.len() - 2, states.len() - 1))
            }
            ASTNode::ZeroOrOne(node) => {
                // [start -> ... -> end]
                //   │               ^
                //   └───────────────┘
                let (start, end) = build_states(node, ranges, states)?;
                states[start].rule_map.push((A::EPSILON, A::EPSILON, end));
                Ok((start, end))
            }
            ASTNode::ZeroOrMore(node) => {
                // [start -> ... -> end] -> new_end
                //   │ ^             │         ^
                //   │ └─────────────┘         │
                //   └─────────────────────────┘
                let (start, end) = build_states(node, ranges, states)?;
                let mut new_end = FAFragment::default();
                states[end].is_accepted = false;
                new_end.is_accepted = true;
                let len = states.len();
                states[start].rule_map.push((A::EPSILON, A::EPSILON, len));
                states[end].rule_map.push((A::EPSILON, A::EPSILON, len));
                states[end].rule_map.push((A::EPSILON, A::EPSILON, start));
                states.push(new_end);
                Ok((start, states.len() - 1))
            }
            ASTNode::OneOrMore(node) => {
                // [start -> ... -> end] -> [start2 -> ... -> end2] -> new_end
                //                            │ ^               │         ^
                //                            │ └───────────────┘         │
                //                            └───────────────────────────┘
                let (start, end) = build_states(node, ranges, states)?;
                let (start2, end2) = build_states(node, ranges, states)?;
                states[end].is_accepted = false;
                states[end2].is_accepted = false;
                states[end].rule_map.push((A::EPSILON, A::EPSILON, start2));
                let new_end = FAFragment {
                    is_accepted: true,
                    ..Default::default()
                };
                let len = states.len();
                states[start2].rule_map.push((A::EPSILON, A::EPSILON, len));
                states[end2].rule_map.push((A::EPSILON, A::EPSILON, len));
                states[end2].rule_map.push((A::EPSILON, A::EPSILON, start2));
                states.push(new_end);
                Ok((start, states.len() - 1))
            }
            ASTNode::Repeat {
                node,
                at_least,
                at_most,
            } => {
                let new_start = FAFragment::default();
                states.push(new_start);
                let new_start = states.len() - 1;
                let new_end = FAFragment {
                    is_accepted: true,
                    ..Default::default()
                };
                states.push(new_end);
                let new_end = states.len() - 1;

                let mut start = new_start;
                for _ in 0..*at_least {
                    let (new_start, new_end) = build_states(node, ranges, states)?;
                    states[start]
                        .rule_map
                        .push((A::EPSILON, A::EPSILON, new_start));
                    states[new_end].is_accepted = false;
                    start = new_end;
                }
                if let &Some(at_most) = at_most {
                    if *at_least > at_most {
                        return Err(FAAssembleError::InvalidQuantifier);
                    }
                    for _ in *at_least..at_most {
                        let (new_start, end) = build_states(node, ranges, states)?;
                        states[start]
                            .rule_map
                            .push((A::EPSILON, A::EPSILON, new_start));
                        states[start]
                            .rule_map
                            .push((A::EPSILON, A::EPSILON, new_end));
                        states[end].is_accepted = false;
                        start = end;
                    }
                    states[start]
                        .rule_map
                        .push((A::EPSILON, A::EPSILON, new_end));
                } else {
                    let (new_start, end) = build_states(node, ranges, states)?;
                    states[start]
                        .rule_map
                        .push((A::EPSILON, A::EPSILON, new_start));
                    states[start]
                        .rule_map
                        .push((A::EPSILON, A::EPSILON, new_end));
                    states[end].rule_map.push((A::EPSILON, A::EPSILON, new_end));
                    states[end]
                        .rule_map
                        .push((A::EPSILON, A::EPSILON, new_start));
                    states[end].is_accepted = false;
                }

                Ok((new_start, new_end))
            }
            ASTNode::RepeatExact(node, n) => {
                let new_start = FAFragment::default();
                states.push(new_start);
                let new_start = states.len() - 1;
                let new_end = FAFragment {
                    is_accepted: true,
                    ..Default::default()
                };
                states.push(new_end);
                let new_end = states.len() - 1;

                let mut start = new_start;
                for _ in 0..*n {
                    let (new_start, end) = build_states(node, ranges, states)?;
                    states[start]
                        .rule_map
                        .push((A::EPSILON, A::EPSILON, new_start));
                    states[end].is_accepted = false;
                    start = end;
                }

                states[start]
                    .rule_map
                    .push((A::EPSILON, A::EPSILON, new_end));

                Ok((new_start, new_end))
            }
        }
    }

    let mut states = vec![];
    let (initial_state, _) = build_states(ast, &ranges, &mut states)?;

    Ok(NFA {
        id: AUTOMATON_ID.fetch_add(1, std::sync::atomic::Ordering::Relaxed),
        initial_state,
        states,
    })
}
